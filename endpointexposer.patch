diff --git a/src/Jellyfin.Plugin.EndpointExposer/Plugin.cs b/src/Jellyfin.Plugin.EndpointExposer/Plugin.cs
new file mode 100644
index 0000000..0000000
--- a/src/Jellyfin.Plugin.EndpointExposer/Plugin.cs
+++ b/src/Jellyfin.Plugin.EndpointExposer/Plugin.cs
@@ -0,0 +1,36 @@
+using System;
+using System.IO;
+using MediaBrowser.Common.Plugins;
+
+namespace Jellyfin.Plugin.EndpointExposer
+{
+    public class Plugin : BasePlugin
+    {
+        public override string Name => "Endpoint Exposer";
+
+        public Plugin()
+            : base()
+        {
+            // Keep constructor trivial and non-throwing.
+            // Defer any network or heavy initialization to OnApplicationStarted or to controllers/services.
+            try
+            {
+                var pluginDir = Path.Combine(
+                    Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) ?? ".",
+                    "jellyfin", "plugins", "Jellyfin.Plugin.EndpointExposer");
+
+                Directory.CreateDirectory(pluginDir);
+            }
+            catch
+            {
+                // swallow: plugin construction must not throw
+            }
+        }
+    }
+}
diff --git a/src/Jellyfin.Plugin.EndpointExposer/HttpHelpers.cs b/src/Jellyfin.Plugin.EndpointExposer/HttpHelpers.cs
new file mode 100644
index 0000000..0000000
--- /dev/null
+++ b/src/Jellyfin.Plugin.EndpointExposer/HttpHelpers.cs
@@ -0,0 +1,86 @@
+using System;
+using System.Net.Http;
+using System.Threading;
+using System.Threading.Tasks;
+
+namespace Jellyfin.Plugin.EndpointExposer
+{
+    internal static class HttpHelpers
+    {
+        // Simple retry with 429 handling and exponential backoff
+        public static async Task<HttpResponseMessage> SendWithRetryAsync(
+            Func<HttpClient, Task<HttpResponseMessage>> action,
+            IHttpClientFactory httpFactory,
+            string clientName = null,
+            int maxRetries = 3,
+            CancellationToken cancellationToken = default)
+        {
+            var client = clientName is null ? httpFactory.CreateClient() : httpFactory.CreateClient(clientName);
+            var attempt = 0;
+            var delay = TimeSpan.FromSeconds(1);
+
+            while (true)
+            {
+                attempt++;
+                try
+                {
+                    var resp = await action(client).ConfigureAwait(false);
+
+                    if ((int)resp.StatusCode == 429 && attempt <= maxRetries)
+                    {
+                        // Respect Retry-After header if present
+                        if (resp.Headers.RetryAfter != null)
+                        {
+                            var retryAfter = resp.Headers.RetryAfter.Delta ?? TimeSpan.FromSeconds(5);
+                            await Task.Delay(retryAfter, cancellationToken).ConfigureAwait(false);
+                        }
+                        else
+                        {
+                            await Task.Delay(delay, cancellationToken).ConfigureAwait(false);
+                            delay = TimeSpan.FromSeconds(Math.Min(delay.TotalSeconds * 2, 30));
+                        }
+
+                        resp.Dispose();
+                        continue;
+                    }
+
+                    return resp;
+                }
+                catch (HttpRequestException) when (attempt <= maxRetries)
+                {
+                    await Task.Delay(delay, cancellationToken).ConfigureAwait(false);
+                    delay = TimeSpan.FromSeconds(Math.Min(delay.TotalSeconds * 2, 30));
+                    if (attempt == maxRetries) throw;
+                }
+            }
+        }
+    }
+}
diff --git a/src/Jellyfin.Plugin.EndpointExposer/Controllers/WatchplannerController.cs b/src/Jellyfin.Plugin.EndpointExposer/Controllers/WatchplannerController.cs
new file mode 100644
index 0000000..0000000
--- /dev/null
+++ b/src/Jellyfin.Plugin.EndpointExposer/Controllers/WatchplannerController.cs
@@ -0,0 +1,56 @@
+using System;
+using System.Threading.Tasks;
+using Microsoft.AspNetCore.Mvc;
+
+namespace Jellyfin.Plugin.EndpointExposer.Controllers
+{
+    [ApiController]
+    [Route("endpoint-exposer/watchplanner")]
+    public class WatchplannerController : ControllerBase
+    {
+        private readonly IHttpClientFactory _httpFactory;
+
+        public WatchplannerController(IHttpClientFactory httpFactory)
+        {
+            _httpFactory = httpFactory ?? throw new ArgumentNullException(nameof(httpFactory));
+        }
+
+        [HttpGet("ping")]
+        public IActionResult Ping()
+        {
+            return Ok(new { status = "ok" });
+        }
+
+        [HttpGet("status")]
+        public async Task<IActionResult> GetStatus()
+        {
+            try
+            {
+                var resp = await HttpHelpers.SendWithRetryAsync(
+                    client => client.GetAsync("https://example.com/status"),
+                    _httpFactory).ConfigureAwait(false);
+
+                if (!resp.IsSuccessStatusCode)
+                {
+                    return StatusCode((int)resp.StatusCode, "Upstream returned non-success");
+                }
+
+                var body = await resp.Content.ReadAsStringAsync().ConfigureAwait(false);
+                return Ok(body);
+            }
+            catch (Exception ex)
+            {
+                // Do not throw during startup; return 500 and log if you have a logger
+                return StatusCode(500, $"Request failed: {ex.Message}");
+            }
+        }
+    }
+}
diff --git a/src/Jellyfin.Plugin.EndpointExposer/PluginDiagnostics.cs b/src/Jellyfin.Plugin.EndpointExposer/PluginDiagnostics.cs
new file mode 100644
index 0000000..0000000
--- /dev/null
+++ b/src/Jellyfin.Plugin.EndpointExposer/PluginDiagnostics.cs
@@ -0,0 +1,160 @@
+using System;
+using System.IO;
+using System.Linq;
+using System.Runtime.CompilerServices;
+
+namespace Jellyfin.Plugin.EndpointExposer
+{
+    internal static class PluginDiagnostics
+    {
+        private const string AssemblyMarker = "assembly-loaded.txt";
+        private const string FirstChanceFile = "firstchance.txt";
+        private const string InitFailedFile = "diagnostics-init-failed.txt";
+
+        [ModuleInitializer]
+        public static void InitModule()
+        {
+            try
+            {
+                var pluginDir = GetPluginDir();
+                Directory.CreateDirectory(pluginDir);
+
+                // Remove previous diagnostics once at init
+                TryDeleteFiles(pluginDir, AssemblyMarker);
+                TryDeleteFiles(pluginDir, FirstChanceFile);
+                TryDeleteFiles(pluginDir, "*-exception-*.txt");
+                TryDeleteFiles(pluginDir, InitFailedFile);
+
+                AppDomain.CurrentDomain.FirstChanceException += (s, e) =>
+                {
+                    try
+                    {
+                        DumpFirstChance(pluginDir, e.Exception);
+                    }
+                    catch
+                    {
+                        // swallow everything; diagnostics must not throw
+                    }
+                };
+
+                TryWriteText(pluginDir, AssemblyMarker, $"Assembly loaded at {DateTime.UtcNow:O}");
+            }
+            catch (Exception ex)
+            {
+                TryWriteText(GetPluginDir(), InitFailedFile, ex.ToString());
+            }
+        }
+
+        private static void DumpFirstChance(string pluginDir, Exception ex)
+        {
+            try
+            {
+                var content = BuildDumpContent(ex);
+                var temp = Path.Combine(pluginDir, $"{FirstChanceFile}.tmp");
+                File.WriteAllText(temp, content);
+
+                var target = Path.Combine(pluginDir, FirstChanceFile);
+
+                try
+                {
+                    if (File.Exists(target))
+                    {
+                        var backup = Path.Combine(pluginDir, $"{FirstChanceFile}.bak");
+                        try
+                        {
+                            File.Replace(temp, target, backup, ignoreMetadataErrors: true);
+                            if (File.Exists(backup))
+                            {
+                                try { File.Delete(backup); } catch { }
+                            }
+                        }
+                        catch
+                        {
+                            try { File.Delete(target); } catch { }
+                            File.Move(temp, target);
+                        }
+                    }
+                    else
+                    {
+                        File.Move(temp, target);
+                    }
+                }
+                catch
+                {
+                    try
+                    {
+                        File.WriteAllText(target, content);
+                        if (File.Exists(temp)) try { File.Delete(temp); } catch { }
+                    }
+                    catch
+                    {
+                        // swallow
+                    }
+                }
+            }
+            catch
+            {
+                // swallow
+            }
+        }
+
+        private static string BuildDumpContent(Exception ex)
+        {
+            try
+            {
+                var sw = new System.Text.StringBuilder();
+                sw.AppendLine($"Timestamp: {DateTime.UtcNow:O}");
+                sw.AppendLine("Exception:");
+                sw.AppendLine(ex?.ToString() ?? "<null>");
+                sw.AppendLine();
+                sw.AppendLine("Environment.StackTrace:");
+                sw.AppendLine(Environment.StackTrace ?? "<no stack>");
+                sw.AppendLine();
+                sw.AppendLine("Loaded assemblies:");
+                foreach (var a in AppDomain.CurrentDomain.GetAssemblies().OrderBy(a => a.GetName().Name))
+                {
+                    try
+                    {
+                        var name = a.GetName();
+                        sw.AppendLine($"{name.Name}, Version={name.Version}, Location={a.Location}");
+                    }
+                    catch
+                    {
+                        sw.AppendLine($"<assembly info unavailable> {a.FullName}");
+                    }
+                }
+                return sw.ToString();
+            }
+            catch
+            {
+                return $"Timestamp: {DateTime.UtcNow:O}\nException: <failed to build dump>\n";
+            }
+        }
+
+        private static void TryWriteText(string pluginDir, string fileName, string text)
+        {
+            try
+            {
+                var path = Path.Combine(pluginDir, fileName);
+                File.WriteAllText(path, text);
+            }
+            catch
+            {
+                // swallow
+            }
+        }
+
+        private static void TryDeleteFiles(string pluginDir, string searchPattern)
+        {
+            try
+            {
+                var files = Directory.GetFiles(pluginDir, searchPattern);
+                foreach (var f in files)
+                {
+                    try { File.Delete(f); } catch { /* ignore */ }
+                }
+            }
+            catch
+            {
+                // swallow
+            }
+        }
+
+        private static string GetPluginDir()
+        {
+            var local = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) ?? ".";
+            return Path.Combine(local, "jellyfin", "plugins", "Jellyfin.Plugin.EndpointExposer");
+        }
+    }
+}
